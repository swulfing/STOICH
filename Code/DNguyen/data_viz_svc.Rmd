---
title: "Visualize SVC results"
author: "David Nguyen"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(varycoef)
library(patchwork)
library(fields)

theme_set(theme_bw())

make_svc_maps <- function(svc_data, point_shape = 21, point_alpha = 0.5) {
  world_map <- map_data("world")
    
  p.pred <- svc_data$fitted %>%
    ggplot() + 
    geom_map(aes(map_id = region), col = "gray", fill = "white", 
           data = world_map, map = world_map) +
    geom_point(aes(
      x = loc_1 ,
      y = loc_2 ,
      col = y.pred
    ), shape = point_shape, alpha = point_alpha) +
    labs(title = "Prediction", x = "Longitude", y = "Latitude",
         col = expression(hat(y))) +
    viridis::scale_color_viridis()
  
  p.int <- svc_data$fitted %>%
    ggplot() + 
    geom_map(aes(map_id = region), col = "gray", fill = "white", 
           data = world_map, map = world_map) +
    geom_point(aes(
      x = loc_1 ,
      y = loc_2 ,
      col = SVC_1 + svc_data$coef[1]
    ), shape = point_shape, alpha = point_alpha) +
    labs(title = "Intercept", x = "Longitude", y = "Latitude",
         col = expression(beta[0] + beta[0](s))) +
    viridis::scale_color_viridis()
  
  p.doc <- svc_data$fitted %>%
    ggplot() + 
    geom_map(aes(map_id = region), col = "gray", fill = "white", 
           data = world_map, map = world_map) +
    geom_point(aes(
      x = loc_1 ,
      y = loc_2 ,
      col = SVC_2 + svc_data$coef[2]
    ), shape = point_shape, alpha = point_alpha) +
    labs(title = "log10(DOC)", x = "Longitude", y = "Latitude",
         col = expression(beta[1] + beta[1](s))) +
    viridis::scale_color_viridis()
  
  p.po4 <- svc_data$fitted %>%
    ggplot() + geom_map(aes(map_id = region), col = "gray", fill = "white", 
           data = world_map, map = world_map) +
    geom_point(aes(
      x = loc_1 ,
      y = loc_2 ,
      col = SVC_3 + + svc_data$coef[3]
    ), shape = point_shape, alpha = point_alpha) +
    labs(title = "log10(P)", x = "Longitude", y = "Latitude",
         col = expression(beta[2] + beta[2](s))) +
    viridis::scale_color_viridis()
  
  gridExtra::grid.arrange(p.pred, p.int, p.doc, p.po4, nrow = 2, ncol = 2)
}

# make grid of new locations to predict spatially varying terms
# filter so that only counties that have sampling locations are included
make_grid <- function(model, grid_size = 0.25, sitethresh = 0) {
  
  # get smallest bounding rectangle which contains the sampling locations
  min_lon <- min(model$data$locs$LON)
  max_lon <- max(model$data$locs$LON)
  min_lat <- min(model$data$locs$LAT)
  max_lat <- max(model$data$locs$LAT)

# create mesh in bounding rectangle
grid_size_degrees <- grid_size
new_grid <- 
  expand.grid(LON = seq(min_lon, max_lon, 
                        by = grid_size_degrees),
              LAT = seq(min_lat, max_lat, 
                        by = grid_size_degrees))

# filter only cells that are within a country (e.g., filter out oceans)
new_grid <- new_grid %>% 
  mutate(country = maps::map.where(database = "world", 
                                   x = LON, y = LAT)) %>% 
  filter(!is.na(country))

# sample_countries <-
#   maps::map.where(database = "world",
#                 x = model$data$locs$LON,
#                 y = model$data$locs$LAT) %>% unique()
# sample_countries <- sample_countries[!is.na(sample_countries)]

# Get all countries that contain sampling locations
# filter countries that have at least sitethresh sites

sample_countries <- model$data$locs %>% 
  mutate(country = maps::map.where(database = "world", 
                x = LON, 
                y = LAT)) %>%
  group_by(country) %>%
  summarise(nsites = n()) %>%
  filter(nsites > sitethresh) %>%
  pull(country)

# remove cells that are not contained in countries with samples
new_grid <- new_grid[new_grid$country %in% sample_countries,]
return(new_grid)
}

# calculate the standard deviation of predicted SVC
# input: 
  # svc.mod: a varycoef::SVC_mle object
  # newlocs: a matrix with columns LON, LAT of predicted points
# value:
  # a matrix w/ columns of standard errors for each SVC_1, SVC_2, ...,  SVC_q
svc_sd <- function(svc.mod, newlocs) {
  # extract estimate range and variance for each svc
  covest <- cov_par(svc.mod)[-length(cov_par(svc.mod))]
  covest <- matrix(covest, nrow = 3, ncol = 2, byrow = TRUE)
  colnames(covest) <- c("range", "var")
  rownames(covest) <- paste0("SVC_", 1:3)
  
  # make matrix to store SVC prediction standard deviation
  svc_sd_mat <- matrix(0, nrow = nrow(newlocs), ncol = nrow(covest))
  colnames(svc_sd_mat) <- paste0(rownames(covest), "_sd")
  
  # make distance matrices
  # y is new points, x is old points
  locs <- svc.mod$data$locs # old locs
  D.yx = fields::rdist(newlocs,locs)
  D.xx = fields::rdist(locs,locs)
  D.yy = fields::rdist(newlocs,newlocs)
  
  # calculate sd for each SVC
  for (SVC_num in 1:nrow(covest)) {
    
    # if estimated variance of GP varying coefficient is 0 do not calculate sd
    if (covest[SVC_num, "var"] < 1e-6) next
    
    # for the second SVC3
    s.xx = covest[SVC_num, "var"]*exp(-D.xx/covest[SVC_num, "range"])
    s.yx = covest[SVC_num, "var"]*exp(-D.yx/covest[SVC_num, "range"])
    s.yy = covest[SVC_num, "var"]*exp(-D.yy/covest[SVC_num, "range"])
    
    # get standard deviation of predicted SVC values
    pre_sd.svc <- s.yy-s.yx %*% solve(s.xx,t(s.yx))
    svc_sd_mat[,SVC_num] <- sqrt(diag(pre_sd.svc))
  }
  
  return(svc_sd_mat)
}

# plot map of sampling locations from SVC_mle object
plot_svc_sites <- function(svc.mod, alphaval = 0.8) {
  # get country polygons
  world_map <- map_data("world")
  
  # plot LON/LAT of all sampling locations
  svc.mod$data$locs %>%
ggplot()  +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    geom_point(aes(
      x = LON ,
      y = LAT 
    ), alpha = alphaval) +
    labs(title = "Sampling locations", x = "Longitude", y = "Latitude"
         )
}

# plot map of sampling locations from SVC_mle object
plot_svc_residuals <- function(svc.mod, alphaval = 0.8, title = NULL) {
  # get country polygons
  world_map <- map_data("world")
  
  res <- residuals(svc.mod)
  locations <- svc.mod$data$locs
  dat <- cbind(res, locations) %>%
    mutate(rsign = ifelse(res < 0, "-", "+"))
  
  # plot LON/LAT of all sampling locations
   dat %>%
ggplot()  +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    geom_point(aes(
      x = LON ,
      y = LAT ,
      col = rsign,
    ), alpha = alphaval) +
    labs(title = title, 
         x = "Longitude", y = "Latitude", 
         col = "Sign of\nresidual"
         )
}


# read in fitted models
# svc_na_lake <- readRDS("Code/DNguyen/models/svc_na_lake.RDS")
svc_na_lake <- readRDS("models/svc_na_lake_tp.RDS")
svc_na_river <- readRDS("models/svc_na_river.RDS")
svc_eu_lake <- readRDS("models/svc_eu_lake_tp.RDS")
svc_eu_river <- readRDS("models/svc_eu_river.RDS")

# original data
cnp <- read.csv("data/ALL_CNP_med.csv")

# split between EU and NA, lakes and rivers
cnp_eu_river <- cnp %>% filter(ECO_TYPE == "River/Stream", region == "Europe")
cnp_eu_lake <- cnp %>% filter(ECO_TYPE == "Lake", region == "Europe") %>%
  filter(!is.na(TP_med))

cnp_na_river <- cnp %>% filter(ECO_TYPE == "River/Stream", region == "North America")
cnp_na_lake <- cnp %>% filter(ECO_TYPE == "Lake", region == "North America")
```



```{r eval = FALSE}
plot_svc_tile <- function(pred, term, title, term_number, x = "loc_1", y = "loc_2", alpha = 0.8,  ...) {
  # get country polygons
  world_map <- map_data("world")
  
  ggplot() + 
    geom_tile(pred,
              aes_string(
      x = loc_1 ,
      y = loc_2 ,
      fill = term
    ), alpha = alpha) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(title = title, x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[term_number](s)))
         ) +
    scale_fill_viridis()
}


plot_svc_tile(pred = pred_eu_lake, term = "SVC_1", title = "Spatial variation of intercept", term_number = 1)
```

<!-- # Outstanding questions -->

<!-- * Are there censoring issue from lower limits of detection? I noticed "lines" in the residuals of the North American lakes (PO4) model. -->
<!-- * Should we "weight" the observations? Since we take medians, an observation that is a median of 5 measurements would have the same influence on the model as a lake with 500 measurements. I did not notice a `weights` argument in the `varycoef` functions. -->
<!--     + possible solution would be just to fit varying intercept models using `mgcv::gam` which does have a `weight` argument. -->
<!--     + If using weights, what value should I use for weights? Since I use annual medians (median of the yearly medians) there are sort of two sample sizes per coordinate (number of years and number of obs within a year.) -->
<!-- * In my opinion, the models don't really fit the data that well based on the diagnostic plots. Thoughts on this? -->

# Overview

I re-fitted SVC models to the CNP data. We subsetted the data into North American lakes (n = `r length(svc_na_lake$data$y)`), North American rivers (n = `r length(svc_na_river$data$y)`), European lakes (n = `r length(svc_eu_lake$data$y)`), and European rivers (n = `r length(svc_eu_river$data$y)`).

The linear predictor for all SVC models was

\begin{align*}
\log(y_i) & = \beta_0 + \beta_0(\textbf{s}_i) \\ 
& + \beta_1 (\log DOC) + \beta_1(\textbf{s}_i) (\log DOC) \\
& + \beta_2 (\log PO4) + \beta_2(\textbf{s}_i) (\log PO4) \\
& + \beta_3 (\log DOC)\times (\log PO4) + \epsilon_i
\end{align*}

Where $y_i$ is the  annual median NO3 for site $i$, and the $\beta_{j}(\textbf{s}_i)$ is the varying slope coefficients (intercept, DOC, PO4) that has distribution $GP(0, \Sigma_j)$ where $\Sigma_j$ has an exponential correlation function. The nugget (residual error) is modeled by as normally distributed ($\epsilon_i \sim N(0, \tau^2)$).

I estimated all SVC models using default starting values. All models succesfully converged.

In each of the following sections, I give the model summary results, fixed effect coefficient plot, and maps of the spatially varying coefficient predictions and the associated uncertainty.

# Lakes

<!-- We have very few lake observations and they were not densely sampled in space. I think this may be why we were unable to calculate standard errors for covariance parameters which, according to the `varycoef` function, was because the Hessian was not invertible. -->

<!-- The signs of the point estimates for the fixed effects were in-line with our expectations from prior models (negative effect of DOC, positive effect of PO4). THe interaction between DOC and PO4 was not significant for NA or EU subsets. -->

<!-- Inspection of the SVCs indicates that much of the variability is in the intercept and the nugget term rather than DOC (no variation) or PO4. -->

<!-- *Note:* the limited number of data sets for lakes is because we only included lakes with PO4 measurements. Apparently, this is not very useful to measure in lakes, so few people measure it. Total phosphorus (tp) is more appropriate to use for lakes and is more commonly measured. The group will gather new lake data and we will move forward using TP instead of PO4. This should take care of the low sample size and sparse spatial coverage issues. -->

### NA lakes TP

```{r eval = FALSE}
make_svc_maps(svc_na_lake, point_alpha = 0.5, point_shape = 21)
```

In the summary output, you can find coefficients estimates and hypothesis tests as well as model R-squared.

Interpretation of the model coefficients can be tricky for models with both response and predictors that are log-transformed. The coefficients can be interpreted as the average % change in the response for a 1% increase in the explanatory variable, holding all other values of the explanatory values constant.

For example, the effect of a 1% increase in median DOC as a sampling site, we expect the median NO3 to decrease by 0.23%, holding all other variables constant.

More generally, we can interpret them for an x percent increase as: 
$(1.x^{\beta} - 1) \times 100$ % where $\beta$ is the coefficient of interest.

See this resource for more details ([Link](https://data.library.virginia.edu/interpreting-log-transformations-in-a-linear-model/)).

```{r}
summary(svc_na_lake)
```

```{r}
coef_na_lake <- 
  summary(svc_na_lake)$coef %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "term") %>%
  mutate(lcl = Estimate - 1.96 * `Std. Error`,
         ucl = Estimate + 1.96 * `Std. Error`)

coef_na_lake %>%
  ggplot(aes(x = term, y = Estimate, ymin = lcl, ymax = ucl)) +
  geom_point(size = 2) +
  geom_errorbar(width = 0) +
  geom_hline(yintercept = 0, linetype = "dashed", col = "red") +
  coord_flip()
```

### Estimated regression

Here's an example of the regression lines for how mean of log median NO3 is expected to change as log of median DOC changes for the 25, 50, and 75th quantiles of log median TP. Note that the uncertainty of the regression lines are much larger than for the OLS model. This is expected because the OLS model incorrectly treats the data as independent even though there is clear spatial correlation. This results in underestimation of uncertainty for OLS model estimates.

```{r}

# Get average regression relationship averaged over space
# Similar to predict.lm
# get regression line and se conditioned on all RE == 0
predict_SVC <- function(svc.mod, Xp) {

  # Get vcov of fixed effects
  Sigma_final <- svc.mod$MLE$comp.args$Sigma_final
  X <- svc_na_lake$MLE$call.args$X
  Sigma_FE <- solve(crossprod(X, solve(Sigma_final, X)))
  
  # get predicted values
  fit <- Xp %*% coef(svc_na_lake)

  # SE = X %*% V %*% t(X)
  var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
  se.fit <- sqrt(var.fit)

  # return output as list
  return(list("fit" = fit, "se.fit" = se.fit))
}

# make Xp the matrix at which to make new predictions
make_Xp <- function(log_P, log_DOC, qvals = c(0.25, 0.5, 0.75)) {

  log_P <- log_P[!is.na(log_P)]
  log_DOC <- log_DOC[!is.na(log_DOC)]
  
  quant_log_p <- quantile(log_P, qvals, na.rm = T)
  quant_log_DOC <- quantile(log_DOC, qvals, na.rm = T)
         
X_DOC <- expand_grid(
                  intercept = 1,
                  log_DOC_med = seq(from = min(log_DOC), 
                                    to = max(log_DOC),
                                    length = 100),
                  log_p_med = quant_log_p
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

X_P <- expand_grid(
                  intercept = 1,
                  log_DOC_med = quant_log_DOC,
                  log_p_med = seq(from = min(log_P), 
                                    to = max(log_P),
                                    length = 100)
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)
  
  return(list(X_DOC = X_DOC, X_P = X_P))
}

qvals <- c(0.25, 0.5, 0.75)

log_P <- log(cnp_na_lake$TP_med)
log_DOC <- log(cnp_na_lake$DOC_med)

quant_log_p <- quantile(log_P, qvals, na.rm = T)
quant_log_DOC <- quantile(log_DOC, qvals, na.rm = T)

X_mat <- make_Xp(log_P = log_P,
        log_DOC = log_DOC, qvals = qvals)

nd_DOC_na <- X_mat$X_DOC

preds_DOC_na <- predict_SVC(svc_na_lake, as.matrix(nd_DOC_na))
nd_DOC_na$pred <- preds_DOC_na$fit
nd_DOC_na$se <- preds_DOC_na$se.fit
nd_DOC_na <- nd_DOC_na %>% mutate(conf.low = pred - 2 * se,
                     conf.high = pred + 2 * se)

nd_DOC_na$region <- "North America"
nd_DOC_na$ECO_TYPE <- "Lake"

nd_DOC_na <-
  nd_DOC_na %>%
  rename("log_phos_med" = log_p_med) %>%
mutate(p_quantile = case_when(
    log_phos_med == quant_log_p[1] ~ "25%",
    log_phos_med == quant_log_p[2] ~ "50%",
    log_phos_med == quant_log_p[3] ~ "75%",
  )
)

nd_DOC_na %>%
  ggplot(aes(x = log_DOC_med, y = pred, ymin = conf.low, ymax = conf.high, fill = factor(log_phos_med))) +
  geom_line(aes(linetype = factor(log_phos_med))) +
  geom_ribbon(alpha = 0.3)

# P
nd_p_na <- X_mat$X_P

preds_p_na <- predict_SVC(svc_na_lake, as.matrix(nd_p_na))
nd_p_na$pred <- preds_p_na$fit
nd_p_na$se <- preds_p_na$se.fit
nd_p_na <- nd_p_na %>% mutate(conf.low = pred - 2 * se,
                     conf.high = pred + 2 * se)


nd_p_na$region <- "North America"
nd_p_na$ECO_TYPE <- "Lake"

nd_p_na <-
  nd_p_na %>%
  rename("log_phos_med" = log_p_med) %>%
mutate(p_quantile = case_when(
    log_DOC_med == quant_log_DOC[1] ~ "25%",
    log_DOC_med == quant_log_DOC[2] ~ "50%",
    log_DOC_med == quant_log_DOC[3] ~ "75%",
  )
)

nd_p_na %>%
  ggplot(aes(x = log_phos_med, y = pred, ymin = conf.low, ymax = conf.high, fill = factor(log_DOC_med))) +
  geom_line(aes(linetype = factor(log_DOC_med))) +
  geom_ribbon(alpha = 0.3)
```


#### SVC maps

Here, I make maps of the predicted spatially varying coeffient (SVC) and the uncertainty of that prediction. 
The top row of maps shows how the coefficients of the fitted linear regression equation relating $\log(NO_3)$ to $\log(DOC)$ and $\log(PO_4)$ change over space.
The bottom row shows the standard error (uncertainty) of these estimated coefficients over space. 
Intuitively, the uncertainty in our estimate of the spatially varying coefficient is small in locations with many observed sites nearby, and the uncertainty is large in locations with very few or no observed sites nearby.

```{r}
# get predicted SVC for new locations
# pred_na_lake <- predict(svc_na_lake, 
#                         newlocs = make_grid(svc_na_lake)[,c(1,2)])

# saveRDS(pred_na_lake, "pred_na_lake.RDS")
pred_na_lake <- readRDS("pred_na_lake.RDS")

# # get sd of predicted SVC for new locations
# na_lake_grid <- make_grid(svc_na_lake, 0.25)[,-3] %>% as.matrix()
# 
# svc_sd_na_lake <- svc_sd(svc_na_lake, na_lake_grid)
# 
# # data frame of locs and SVC standard deviations
# pred_sd_na_lake <- cbind(na_lake_grid, svc_sd_na_lake) %>% data.frame()
# 
# # save sd of predicted SVC
# saveRDS(pred_sd_na_lake, file = "pred_sd_na_lake.RDS")

# load previously calculated sd of predicted SVC
pred_sd_na_lake <- readRDS("pred_sd_na_lake.RDS")
```


```{r}
### SVC maps for na lakes
world_map <- map_data("world")
state_map <- map_data("state")

# plot na lake SVC_1
p_na_lake_svc1 <- pred_na_lake %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_1 + svc_na_lake$coefficients[1]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs( #title = "Spatial variation of intercept", 
         x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[0] + beta[0](s)))
         ) +
  coord_fixed() +
    scale_fill_viridis() +
  theme(legend.position = "top")

# plot na lake SVC_1 standard error
p_na_lake_svc1_sd <- pred_sd_na_lake %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_1_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying intercept", 
         x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
  coord_fixed() +
    scale_fill_viridis() +
  theme(legend.position = "top")


# plot na lake SVC_1 and uncertainty together
# p_na_lake_svc1 + p_na_lake_svc1_sd

```

```{r}
# plot na lake SVC_2 
p_na_lake_svc2 <- 
  pred_na_lake %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_2 + svc_na_lake$coefficients[2]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[1] + beta[1](s)))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

p_na_lake_svc2_sd <- pred_sd_na_lake %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_2_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot na lake SVC_2 and uncertainty together
# p_na_lake_svc2 + p_na_lake_svc2_sd
```


```{r}
# plot na lake SVC_3
p_na_lake_svc3 <- 
  pred_na_lake %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_3 + svc_na_lake$coefficients[3]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(TP)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[2] + beta[2](s)))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

p_na_lake_svc3_sd <- pred_sd_na_lake %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_3_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(PO4)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[3](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot na lake SVC_3 and uncertainty together
# p_na_lake_svc3 + p_na_lake_svc3_sd
```


```{r}
# plot svc maps together
p_na_lake_svc1 + p_na_lake_svc1_sd
p_na_lake_svc2 + p_na_lake_svc2_sd  
p_na_lake_svc3 + p_na_lake_svc3_sd
```


### EU lakes


```{r}
coef_eu_lake <- 
  summary(svc_na_lake)$coef %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "term") %>%
  mutate(lcl = Estimate - 1.96 * `Std. Error`,
         ucl = Estimate + 1.96 * `Std. Error`)

coef_eu_lake %>%
  ggplot(aes(x = term, y = Estimate, ymin = lcl, ymax = ucl)) +
  geom_point(size = 2) +
  geom_errorbar(width = 0) +
  geom_hline(yintercept = 0, linetype = "dashed", col = "red") +
  coord_flip()
```

### Estimated regression

Here's an example of the regression lines for how mean of log median NO3 is expected to change as log of median DOC changes for the 25, 50, and 75th quantiles of log median TP. Note that the uncertainty of the regression lines are much larger than for the OLS model. This is expected because the OLS model incorrectly treats the data as independent even though there is clear spatial correlation. This results in underestimation of uncertainty for OLS model estimates.

```{r}
# Get vcov of fixed beta
Sigma_final <- svc_eu_lake$MLE$comp.args$Sigma_final
X <- svc_eu_lake$MLE$call.args$X
Sigma_FE <- solve(crossprod(X, solve(Sigma_final, X)))

# make new design matrix

log_P <- log(cnp_eu_lake$TP_med)
log_DOC <- log(cnp_eu_lake$DOC_med)

quant_log_p <- quantile(log_P, c(0.25, 0.5, 0.75), na.rm = T)
quant_log_DOC <- quantile(log_DOC, c(0.25, 0.5, 0.75), na.rm = T)
         
X_DOC <- expand_grid(
                  intercept = 1,
                  log_DOC_med = seq(from = min(log_DOC), 
                                    to = max(log_DOC),
                                    length = 100),
                  log_p_med = quant_log_p
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

X_P <- expand_grid(
                  intercept = 1,
                  log_DOC_med = quant_log_DOC,
                  log_p_med = seq(from = min(log_P), 
                                    to = max(log_P),
                                    length = 100)
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

# DOC
pred <- X_DOC # rbind(X_DOC, X_P)
Xp <- as.matrix(pred)

# SE = X %*% V %*% t(X)
var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
se.fit <- sqrt(var.fit)

fit <- Xp %*% coef(svc_eu_lake)

pred$fit <- fit
pred$se.fit <- se.fit

pred <- pred %>% mutate(lwr = fit - 1.96 * se.fit,
                upr = fit + 1.96 * se.fit)

pred %>%
  ggplot(aes(x = log_DOC_med, y = fit, ymin = lwr, ymax = upr, fill = factor(log_p_med))) +
  geom_line(aes(linetype = factor(log_p_med))) +
  geom_ribbon(alpha = 0.3)

# P
pred <- X_P # rbind(X_DOC, X_P)
Xp <- as.matrix(pred)

# SE = X %*% V %*% t(X)
var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
se.fit <- sqrt(var.fit)

fit <- Xp %*% coef(svc_eu_lake)

pred$fit <- fit
pred$se.fit <- se.fit

pred <- pred %>% mutate(lwr = fit - 1.96 * se.fit,
                upr = fit + 1.96 * se.fit)

pred %>%
  ggplot(aes(x = log_p_med, y = fit, ymin = lwr, ymax = upr, fill = factor(log_DOC_med))) +
  geom_line(aes(linetype = factor(log_DOC_med))) +
  geom_ribbon(alpha = 0.3)
```

#### SVC maps


```{r}
# load previously calculated sd of predicted SVC
pred_sd_eu_lake <- readRDS("pred_sd_eu_lake.RDS")

# get predicted SVC for new locations
# pred_eu_lake <- predict(svc_eu_lake,
#                         newlocs = pred_sd_eu_lake %>% select(LON,LAT) %>% as.matrix() )
# saveRDS(pred_eu_lake, "pred_eu_lake.RDS")
pred_eu_lake <- readRDS("pred_eu_lake.RDS")


```


```{r}
### SVC maps for EU lakes
world_map <- map_data("world")

# plot EU lake SVC_1
p_eu_lake_svc1 <- pred_eu_lake %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_1 + svc_eu_lake$coefficients[1]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of intercept", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[0] + beta[0](s)))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU lake SVC_1 standard error
p_eu_lake_svc1_sd <- pred_sd_eu_lake %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_1_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying intercept", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU lake SVC_1 and uncertainty together
# p_eu_lake_svc1 + p_eu_lake_svc1_sd

```


```{r}
# plot EU lake SVC_2 
p_eu_lake_svc2 <- 
  pred_eu_lake %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_2 + svc_eu_lake$coefficients[2]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(DOC)", 
         x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[1] + beta[1](s)))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

p_eu_lake_svc2_sd <- pred_sd_eu_lake %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_2_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU lake SVC_2 and uncertainty together
# p_eu_lake_svc2 + p_eu_lake_svc2_sd
```


```{r}
# plot EU lake SVC_3
p_eu_lake_svc3 <- 
  pred_eu_lake %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_3 + svc_eu_lake$coefficients[3]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(TP)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[2] + beta[2](s)))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

p_eu_lake_svc3_sd <- pred_sd_eu_lake %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_3_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(PO4)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[3](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU lake SVC_3 and uncertainty together
# p_eu_lake_svc3 + p_eu_lake_svc3_sd
```


```{r}
p_eu_lake_svc1 + p_eu_lake_svc1_sd
p_eu_lake_svc2 + p_eu_lake_svc2_sd
p_eu_lake_svc3 + p_eu_lake_svc3_sd
```


```{r}
summary(svc_na_lake)
```


# Rivers

### NA river

```{r eval = FALSE}
make_svc_maps(svc_na_river)
```

```{r}
summary(svc_na_river)
```

```{r}
coef_na_river <- 
  summary(svc_na_river)$coef %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "term") %>%
  mutate(lcl = Estimate - 1.96 * `Std. Error`,
         ucl = Estimate + 1.96 * `Std. Error`)

coef_na_river %>%
  ggplot(aes(x = term, y = Estimate, ymin = lcl, ymax = ucl)) +
  geom_point(size = 2) +
  geom_errorbar(width = 0) +
  geom_hline(yintercept = 0, linetype = "dashed", col = "red") +
  coord_flip()
```


### Estimated regression


```{r}
# Get vcov of fixed beta
Sigma_final <- svc_na_river$MLE$comp.args$Sigma_final
X <- svc_na_river$MLE$call.args$X
Sigma_FE <- solve(crossprod(X, solve(Sigma_final, X)))

# make new design matrix

log_P <- log(cnp_na_river$TP_med)
log_DOC <- log(cnp_na_river$DOC_med)

quant_log_p <- quantile(log_P, c(0.25, 0.5, 0.75), na.rm = T)
quant_log_DOC <- quantile(log_DOC, c(0.25, 0.5, 0.75), na.rm = T)
         
X_DOC <- expand_grid(
                  intercept = 1,
                  log_DOC_med = seq(from = min(log_DOC, na.rm = T), 
                                    to = max(log_DOC, na.rm = T),
                                    length = 100),
                  log_p_med = quant_log_p
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

X_P <- expand_grid(
                  intercept = 1,
                  log_DOC_med = quant_log_DOC,
                  log_p_med = seq(from = min(log_P, na.rm = T), 
                                    to = max(log_P, na.rm = T),
                                    length = 100)
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

# DOC
pred <- X_DOC # rbind(X_DOC, X_P)
Xp <- as.matrix(pred)

# SE = X %*% V %*% t(X)
var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
se.fit <- sqrt(var.fit)

fit <- Xp %*% coef(svc_na_river)

pred$fit <- fit
pred$se.fit <- se.fit

pred <- pred %>% mutate(lwr = fit - 1.96 * se.fit,
                upr = fit + 1.96 * se.fit)

pred %>%
  ggplot(aes(x = log_DOC_med, y = fit, ymin = lwr, ymax = upr, fill = factor(log_p_med))) +
  geom_line(aes(linetype = factor(log_p_med))) +
  geom_ribbon(alpha = 0.3)

# P
pred <- X_P # rbind(X_DOC, X_P)
Xp <- as.matrix(pred)

# SE = X %*% V %*% t(X)
var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
se.fit <- sqrt(var.fit)

fit <- Xp %*% coef(svc_na_river)

pred$fit <- fit
pred$se.fit <- se.fit

pred <- pred %>% mutate(lwr = fit - 1.96 * se.fit,
                upr = fit + 1.96 * se.fit)

pred %>%
  ggplot(aes(x = log_p_med, y = fit, ymin = lwr, ymax = upr, fill = factor(log_DOC_med))) +
  geom_line(aes(linetype = factor(log_DOC_med))) +
  geom_ribbon(alpha = 0.3)
```

#### SVC maps

```{r}
# # get predicted SVC for new locations
# pred_na_river <- predict(svc_na_river, 
#                         newlocs = make_grid(svc_na_river)[,c(1,2)])
# 
# # save sd of predicted SVC
# saveRDS(pred_na_river, file = "pred_na_river.RDS")

# load previously calculated sd of predicted SVC
pred_na_river <- readRDS("pred_na_river.RDS")

# # get sd of predicted SVC for new locations
# na_river_grid <- make_grid(svc_na_river, 1)[,-3] %>% as.matrix()
# 
# svc_sd_na_river <- svc_sd(svc_na_river, na_river_grid)
# 
# # data frame of locs and SVC standard deviations
# pred_sd_na_river <- cbind(na_river_grid, svc_sd_na_river) %>% data.frame()
# 
# # # save sd of predicted SVC
# saveRDS(pred_sd_na_river, file = "pred_sd_na_river.RDS")

# load previously calculated sd of predicted SVC
pred_sd_na_river <- readRDS("pred_sd_na_river.RDS")
```

```{r}
# na_river_countries <- svc_na_river$data$locs %>% 
#   mutate(country = maps::map.where(database = "world", 
#                 x = LON, 
#                 y = LAT)) %>%
#   group_by(country) %>%
#   summarise(nsites = n()) %>%
#   filter(nsites > 50) %>%
#   pull(country)
# 
# make_grid(svc_na)
```



```{r}
### SVC maps for na rivers
world_map <- map_data("world")

# plot na river SVC_1
p_na_river_svc1 <- pred_na_river %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_1 + svc_na_river$coefficients[1]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of intercept", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[0] + beta[0](s)))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot na river SVC_1 standard error
p_na_river_svc1_sd <- pred_sd_na_river %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_1_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying intercept", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot na river SVC_1 and uncertainty together
# p_na_river_svc1 + p_na_river_svc1_sd

```

```{r}
# plot na river SVC_2 
p_na_river_svc2 <- 
  pred_na_river %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_2 + svc_na_river$coefficients[2]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[1] + beta[1](s)))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

p_na_river_svc2_sd <- pred_sd_na_river %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_2_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[2] + beta[2](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot na river SVC_2 and uncertainty together
# p_na_river_svc2 + p_na_river_svc2_sd
```


```{r}
# plot na river SVC_3
p_na_river_svc3 <- 
  pred_na_river %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_3 + svc_na_river$coefficients[3]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#Etitle = "Spatial variation of slope of log(TP)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[2] + beta[2](s)))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

p_na_river_svc3_sd <- pred_sd_na_river %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_3_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = state_map, map = state_map) +
  geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(PO4)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[3](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot na river SVC_3 and uncertainty together
# p_na_river_svc3 + p_na_river_svc3_sd
```

```{r}
p_na_river_svc1 + p_na_river_svc1_sd
p_na_river_svc2 + p_na_river_svc2_sd
p_na_river_svc3 + p_na_river_svc3_sd

```


### EU river

The spatial patterns are much smoother (larger range estimate) compared to previous SVC fit to the "country" level regions. For instance, the range estimate for the intercept is now 17 degrees compared to 2 degrees estimated from the French subset. Because of this, the spatial patterns are much smoother but it appears we lose some of the finer grain spatial insights that we previously saw. However, I think some of the interpretations are still qualitatively the same. 

For example, in the French region, we still see spatial pattern that matches land use changes over space: higher values in the northwest (Jess said this region is traditionally used for agriculture) and lower intercept in the southwest (Jess - prarie/grasslands, Linnea - mountains).

Unfortunately, this model still has some issues (see diagnostic plots at end.)

```{r eval = FALSE}
make_svc_maps(svc_eu_river, point_alpha = 0.5, point_shape = 21)
```

```{r}
summary(svc_eu_river)
```

### Estimated regression

Here's an example of the regression lines for how mean of log median NO3 is expected to change as log of median DOC changes for the 25, 50, and 75th quantiles of log median TP. Note that the uncertainty of the regression lines are much larger than for the OLS model. This is expected because the OLS model incorrectly treats the data as independent even though there is clear spatial correlation. This results in underestimation of uncertainty for OLS model estimates.

```{r}
# Get vcov of fixed beta
Sigma_final <- svc_eu_river$MLE$comp.args$Sigma_final
X <- svc_eu_river$MLE$call.args$X
Sigma_FE <- solve(crossprod(X, solve(Sigma_final, X)))

# make new design matrix

log_P <- log(cnp_eu_river$TP_med)
log_DOC <- log(cnp_eu_river$DOC_med)

quant_log_p <- quantile(log_P, c(0.25, 0.5, 0.75), na.rm = T)
quant_log_DOC <- quantile(log_DOC, c(0.25, 0.5, 0.75), na.rm = T)
         
X_DOC <- expand_grid(
                  intercept = 1,
                  log_DOC_med = seq(from = min(log_DOC), 
                                    to = max(log_DOC),
                                    length = 100),
                  log_p_med = quant_log_p
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

X_P <- expand_grid(
                  intercept = 1,
                  log_DOC_med = quant_log_DOC,
                  log_p_med = seq(from = min(log_P, na.rm = T), 
                                    to = max(log_P, na.rm = T),
                                    length = 100)
                  ) %>%
  mutate(interaction_term = log_DOC_med * log_p_med)

# DOC
pred <- X_DOC # rbind(X_DOC, X_P)
Xp <- as.matrix(pred)

# SE = X %*% V %*% t(X)
var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
se.fit <- sqrt(var.fit)

fit <- Xp %*% coef(svc_eu_river)

pred$fit <- fit
pred$se.fit <- se.fit

pred <- pred %>% mutate(lwr = fit - 1.96 * se.fit,
                upr = fit + 1.96 * se.fit)

pred %>%
  ggplot(aes(x = log_DOC_med, y = fit, ymin = lwr, ymax = upr, fill = factor(log_p_med))) +
  geom_line(aes(linetype = factor(log_p_med))) +
  geom_ribbon(alpha = 0.3)

# P
pred <- X_P # rbind(X_DOC, X_P)
Xp <- as.matrix(pred)

# SE = X %*% V %*% t(X)
var.fit <- rowSums((Xp %*% Sigma_FE) * Xp)
se.fit <- sqrt(var.fit)

fit <- Xp %*% coef(svc_eu_river)

pred$fit <- fit
pred$se.fit <- se.fit

pred <- pred %>% mutate(lwr = fit - 1.96 * se.fit,
                upr = fit + 1.96 * se.fit)

pred %>%
  ggplot(aes(x = log_p_med, y = fit, ymin = lwr, ymax = upr, fill = factor(log_DOC_med))) +
  geom_line(aes(linetype = factor(log_DOC_med))) +
  geom_ribbon(alpha = 0.3)
```

#### SVC maps

```{r}
# # get predicted SVC for new locations
# pred_eu_river <- predict(svc_eu_river, 
#                         newlocs = make_grid(svc_eu_river)[,c(1,2)])
# 
# # # # save sd of predicted SVC
# saveRDS(pred_eu_river, file = "pred_eu_river.RDS")

# load previously calculated sd of predicted SVC
pred_eu_river <- readRDS("pred_eu_river.RDS")

# # get sd of predicted SVC for new locations
# eu_river_grid <- make_grid(svc_eu_river, 1)[,-3] %>% as.matrix()
# 
# svc_sd_eu_river <- svc_sd(svc_eu_river, eu_river_grid)
# 
# # data frame of locs and SVC standard deviations
# pred_sd_eu_river <- cbind(eu_river_grid, svc_sd_eu_river) %>% data.frame()
# 
# # # save sd of predicted SVC
# saveRDS(pred_sd_eu_river, file = "pred_sd_eu_river.RDS")

# load previously calculated sd of predicted SVC
pred_sd_eu_river <- readRDS("pred_sd_eu_river.RDS")
```


```{r}
### SVC maps for EU rivers
world_map <- map_data("world")

# plot EU river SVC_1
p_eu_river_svc1 <- pred_eu_river %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_1 + svc_eu_river$coefficients[1]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of intercept", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[0] + beta[0](s)))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU river SVC_1 standard error
p_eu_river_svc1_sd <- pred_sd_eu_river %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_1_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying intercept", 
         x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU river SVC_1 and uncertainty together
# p_eu_river_svc1 + p_eu_river_svc1_sd

```

```{r}
# plot EU river SVC_2 
p_eu_river_svc2 <- 
  pred_eu_river %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_2 + svc_eu_river$coefficients[2]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[1] + beta[1](s)))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

p_eu_river_svc2_sd <- pred_sd_eu_river %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_2_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(DOC)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[1] + beta[1](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU river SVC_2 and uncertainty together
# p_eu_river_svc2 + p_eu_river_svc2_sd
```

```{r}
# plot EU river SVC_3
p_eu_river_svc3 <- 
  pred_eu_river %>%
ggplot() + 
    geom_tile(aes(
      x = loc_1 ,
      y = loc_2 ,
      fill = SVC_3 + svc_eu_river$coefficients[3]
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Spatial variation of slope of log(TP)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(widehat(beta[2] + beta[2](s)))
         ) +
    scale_fill_viridis()  +
  theme(legend.position = "top") +
  coord_fixed()

p_eu_river_svc3_sd <- pred_sd_eu_river %>%
ggplot() + 
    geom_tile(aes(
      x = LON ,
      y = LAT ,
      fill = SVC_3_sd
    ), alpha = 1) +
    geom_map(aes(map_id = region), col = "gray", fill = NA, 
           data = world_map, map = world_map) +
    labs(#title = "Uncertainty of spatially varying slope of log(PO4)", 
      x = "Longitude", y = "Latitude"
         ,fill = expression(sd(widehat(beta[3](s))))
         ) +
    scale_fill_viridis() +
  theme(legend.position = "top") +
  coord_fixed()

# plot EU river SVC_3 and uncertainty together
# p_eu_river_svc3 + p_eu_river_svc3_sd
```

```{r}
p_eu_river_svc1 + p_eu_river_svc1_sd
p_eu_river_svc2 + p_eu_river_svc2_sd
p_eu_river_svc3  + p_eu_river_svc3_sd


```


# Diagnostic plots

The fitted vs. residuals plots show some sign of bias for NA and EU lakes where the model overestimates low NO3 sites and underestimates high NO3 sites. Fitted vs. residuals plots for the rivers do not show this issue.

From the QQ-plots we can see that the model residuals are heavy-tailed for all subsets. For the lakes this could be a consequence of the model bias mentioned previously. For both lakes and rivers it could also be because all the observations are weighted equally during model fitting even though our response is a median taken over different sample sizes for each site. This means that sites with small numbers of observations "weigh" as much as sites that have very many. These sites with smaller numbers of observations could show up as outliers.

<!-- Not sure how to address this. Could we use an adjusted standard error? I know methods exist for adjusting SE when residuals have heteroscedasticity and/or autocorrelation. -->

### NA lakes


```{r eval = FALSE}
plot(svc_na_lake)

pred_y <- fitted(svc_na_lake)$y.pred
resid_y <- residuals(svc_na_lake)

plot(resid_y ~ pred_y)

no3 <- svc_na_lake$data$y

hist(no3)
```


```{r}
# all.equal(svc_na_lake$data$y - svc_na_lake$fitted$y.pred, residuals(svc_na_lake))
# 
# all.equal(predict(svc_na_lake, newX = svc_na_lake$data$X, newW = svc_na_lake$data$W)$y.pred, svc_na_lake$fitted$y.pred)
# 
# coef(svc_na_lake)
# head(svc_na_lake$data$X) %*% matrix(svc_na_lake$coefficients, ncol = 1, nrow = 4) + 
# head(svc_na_lake$fitted$y.pred)
plot(svc_na_lake)
```

### EU lakes

Not much data here, but less evidence of bias found in the NA lakes subset. Still have heavy tailed residuals.

```{r}
plot(svc_eu_lake)
```

### NA river



```{r}
plot(svc_na_river)
```

### EU river

```{r}
plot(svc_eu_river)
```

# residual spatial autocorrelation

We do not see patterns in the sign of the model errors (residuals) for the SVC models. This is in contrast to the OLS model residual maps which show strong clustering in residual patterns. This means that statistical inferences (hypothesis test, confidence intervals) for the SVC models will be more justifiable than the inferences from the OLS model because assumptions about residual error are better satisfied by the SVC model than for the OLS model.

```{r}
plot_svc_residuals(svc_na_lake, title = "NA lakes")
plot_svc_residuals(svc_eu_lake, title = "EU lakes")
plot_svc_residuals(svc_na_river, title = "NA rivers")
plot_svc_residuals(svc_eu_river, title = "EU rivers")

```

# Spatial variation or non-linearity?


### EU river
```{r}
svc_eu_df <- cbind(svc_eu_river$data$X[,2:3], svc_eu_river$fitted)
plot(svc_eu_df$SVC_2 ~ svc_eu_df$`log(DOC_med)`)
plot(svc_eu_df$SVC_3 ~ svc_eu_df$`log(P_med)`)
```

### EU lake

```{r}
svc_eu_df <- cbind(svc_eu_lake$data$X[,2:3], svc_eu_lake$fitted)
plot(svc_eu_df$SVC_2 ~ svc_eu_df$`log(DOC_med)`)
plot(svc_eu_df$SVC_3 ~ svc_eu_df$`log(TP_med)`)
```

### na lake

```{r}
svc_na_df <- cbind(svc_na_lake$data$X[,2:3], svc_na_lake$fitted)
plot(svc_na_df$SVC_2 ~ svc_na_df$`log(DOC_med)`)
plot(svc_na_df$SVC_3 ~ svc_na_df$`log(TP_med)`)
```

### na river

```{r}
svc_na_df <- cbind(svc_na_river$data$X[,2:3], svc_na_river$fitted)
plot(svc_na_df$SVC_2 ~ svc_na_df$`log(DOC_med)`)
plot(svc_na_df$SVC_3 ~ svc_na_df$`log(P_med)`)
```